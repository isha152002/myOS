1) os.h FILE
os.h defines the OS contract: basic types, OS concepts, and system-call interfaces without relying on the C standard library. This file will eventually be included by command, osapi, kernel. This is exactly what real OS headers do (unistd.h, sys/types.h).

char is a language convenience; int8 is a hardware guarantee. OS code always prefers guarantees.
char exists without stdlib ✔️
But char is ambiguous
OS code wants: exact size, exact sign, exact meaning
typedef unsigned char int8; gives all three

OS ERROR language
Bit flags mean each bit represents a separate condition, so multiple conditions can be stored in one number.
ErrNoErr  = 0   → 0000
ErrInit   = 1   → 0001
ErrIO     = 4   → 0100
ErrBadFD  = 8   → 1000
Each error turns ON exactly ONE switch. Imagine this situation: System not initialized AND file descriptor is bad
You want to record both problems, not just one. With bit flags, you can: turn ON the Init error bit and turn ON the BadFD bit. Now your error state remembers both causes.

public means other files can use this name; private means only this file can use it.

2) osapi.h FILE
osapi.h is the bridge between your “fake OS world” (os.h) and the real OS (Linux / Windows / macOS).

This file is not kernel, and not command.com.
It is the translator layer.

//#define getposixfd(x) fds[(x)]
Your OS uses: small fake file descriptors (fd),simple numbers
The real OS uses: real POSIX file descriptors
So you need a mapping.
This macro means: “Convert my OS fd into a real OS fd.”
When your OS API opens a file, the host OS returns a POSIX fd.
Your OS API stores that POSIX fd in an internal array.
Later, when the user passes a D-DOS fd, you look it up in that array.

**********************************************

//Right now we interact with POSIX because we are using the kernel of our laptop.
When we write our own kernel, POSIX will not be needed at all.
Once you write your own kernel, your osapi will replace POSIX as the interface between applications and the kernel.

Can you make an OS without POSIX?
✅ Yes, absolutely.
Real DOS, Windows, Linux kernels did not “use POSIX” to exist.
An OS only needs a kernel and a system call interface.
POSIX is optional — it’s a standard for user-space programs, not a requirement for an OS.

Think of POSIX like training wheels on a bike:
You could ride a bike without them (write your own kernel now).
But training wheels let you learn balance first (build the OS logic, commands, shell) without falling on your face.
Later, you remove POSIX (training wheels) and your OS runs directly on the kernel.

#No need to write a kernel yet: Your kernel doesn’t exist; POSIX lets you call existing kernel functions for file, memory, and process management.                                       
#Portability: You can run your D-DOS on Linux, Windows (via Cygwin/WSL), macOS, without changing code.      
#Focus on OS logic first: You can develop shell commands, parsing, STDIN/STDOUT handling, etc., without worrying about CPU modes or hardware.  
#Safety: POSIX + libc handles CPU mode switches, registers, and error checking. If you called syscalls directly or hardware, a small bug could crash your system.
#Learning in stages: First learn application layer + API abstraction → then replace POSIX with your kernel → then learn system-level programming gradually.              
**************************************************

3) osapi.c

In every Unix-like OS (Linux, macOS, Cygwin, WSL, etc.), file descriptors 0, 1, and 2 are reserved and always open.
1) 0 = stdin = standard input : When you call read(0, ...), you are reading from keyboard.
2) 1 = stdout = standard output : write(1, "hello\n", 6);  // prints to screen
3) 2 = stderr (standard error) : File descriptor 2 is error output (also printed to terminal, but separate stream).

but in our OS we will change those conventions

//private fd fds[256];
| Index (`fds[index]`) | Meaning  |
| -------------------- | -------- |
| index                | D-DOS fd |
| value                | POSIX fd |


//isopen()
What is struct stat?
struct stat is a C structure defined by the OS (POSIX systems). Its job is to hold information (metadata) about a file or device

why check fd<3?
| fd  | Owner       |
| --- | ----------- |
| 0–2 | Host OS     |
| ≥3  | Your OS API |
Even if your OS creates fds starting from 3, users can still pass 0, 1, or 2 into your API, and you must defend against that.

//setupfds()

Your OS fd   --->   POSIX fd   --->   Where it goes
--------------------------------------------------
0            --->   1          --->   stdout
1            --->   2          --->   stderr
